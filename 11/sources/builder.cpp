#include "builder.hpp"

// мы можем ввести опцию как аргумент командной строки
// Boost.Program_options - библиотека для разбора параметров командной строки
// класс  po::options_description хранит описание опций, то есть там хранится то,
// что будет выводиться, когда мы введем определенный аргумент командной строки
// здесь: ("config", value<std::string>(), "указываем конфигурацию сборки (по умолчанию Debug)")
// "config" - длинное имя аргумента,
// value<std::string>() указывает на то, в какой тип будет преобразовываться аргумент
// "указываем конфигурацию сборки (по умолчанию Debug)"-это описание опции

void build(int argc, char* argv[]) {//argc-кол-во параметров, argv-строка из командной строки
    options_description desc("Allowed options"); // класс po::options_description desc хранит описание опций
    desc.add_options() //помещение в desc опций
        ("help", "выводим вспомогательное сообщение")
        ("config", value<std::string>(), "указываем конфигурацию сборки (по умолчанию Debug)")
        ("install", "добавляем этап установки (в директорию _install)")
        ("pack", "добавляем этап упаковки (в архив формата tar.gz)")
        ("timeout", value<time_t>(), "указываем время ожидания (в секундах)")
    ;//time_t – арифметический тип, представляет собой целочисленное значение – число секунд, прошедших с 00:00, 1 января 1970

// variables_map – класс, в котором будет собираться вся информация об опциях
// parse_command_line возвращает объект, который потом записывается в переменную,
// собирающую информацию об опциях, с помощью функции store
// Если параметры по какой-то причине не получилось разобрать, то parse_command_line выкинет исключение типа error

    variables_map vm; //класс, в котором будет собираться вся информация об опциях
    //далее вызов store, parse_command_line and notify заставляют vm содержать все параметры, найденные в командной строке.
    store(parse_command_line(argc, argv, desc), vm); // парсим командную сроку и помещаем в vm
    notify(vm); // Ловушка (уведомление), выводит компактные уведомления
    // *Запускает все функции-«уведомления» для опций в vm.
    // как только окончательное значение параметра определяется, любое действие, которое следует предпринять с этой опцией,
    // может быть выполнено автоматически и инкапсулировано в его собственную функцию.

    // вывод всех опций //vm.count не равно 0 //count()-возвращает число элементов
    if (vm.count("help") && !vm.count("config")  && !vm.count("pack")
                         && !vm.count("timeout") && !vm.count("install")) {
        std::cout << desc << "\n";//вывод всех опций содержащихся в desc
    }
    else {
        std::string config = "Debug";
        time_t timeout =  time_now(); // возвращает временную точку, представляющую текущее время
        time_t time_spent = 0; //time_t – арифметический тип, представляет собой целочисленное значение – число секунд, прошедших с 00:00, 1 января 1970
        if (vm.count("timeout")) {
            timeout = vm["timeout"].as<time_t>(); // заносится в timeout значение из командной строки
        }
        //Класс variables_map можно использовать точно так же, как std:: map, за исключением того,
        // что хранящиеся там значения должны быть получены с помощью метода as
        if (vm.count("config")) {
            config = vm["config"].as<std::string>(); // заносится в config значение из командной строки
        }

        //заносим в переменные описание эквивалентных запусков процессов программы CMake.
        //command_1 и command_2 используются при любои вызове опции, кроме help
        //command_3 используется при вызове опции install
        //command_4 используется при вызове опции pack
        std::string command_1 = "cmake -H. -B_build -DCMAKE_INSTALL_" +
                             std::string("PREFIX=_install -DCMAKE_BUILD_TYPE=");
        std::string command_2 = "cmake --build _build";
        std::string command_3 = "cmake --build _build --target install";
        std::string command_4 = "cmake --build _build --target package";

        if (config == "Debug" || config == "Release") {
            int res_1 = 0;
            int res_2 = 0;
            command_1 += config; // в конец строки command_1 пишется "Debug" или "Release"

            // async - библиотека для реализации цепочки событий(для ассинхронных процессов)
            //spawn () будет асинхронно запускать данную функцию в пуле потоков и возвращать задачу, связанную с результатом функции.
            //ключевое слово auto при инициализации переменной может использоваться вместо типа переменной, чтобы сообщить компилятору,
            //что он должен присвоить тип переменной исходя из инициализируемого значения.
            // mutable можно добавить к переменным класса для указания того,что данная переменная может изменяться даже в константном контексте.
            // в квадратных скобках параметры, с которыми мы будем работать в методах
            auto t1 = async::spawn([&res_1, config, timeout, &time_spent,  //процесс сборки
                                    command_1, command_2] () mutable {
                time_t start_1 = time_now(); // возвращает временную точку, представляющую текущее время старта первого процесса
                //time_t – арифметический тип, представляет собой целочисленное значение – число секунд, прошедших с 00:00, 1 января 1970
                create_child(command_1, timeout); // создаем первый процесс
                time_t end_1 = time_now();// возвращает временную точку, представляющую текущее время завершения первого процесса
                time_spent += end_1 - start_1; //time_spent заносим время работы первого процесса

                time_t period_2 = timeout - time_spent; // из времени ожидания вычитаем время выполнения певрого процесса
                // и получаем оставшееся время для выполнения остальных процессов

                create_child(command_2, period_2, res_1); // создаем второй процесс, в res_1 будет храниться код выхода из этого процесса
                time_t end_2 = time_now();// возвращает временную точку, представляющую текущее время завершения второго процесса
                time_spent += end_2 - end_1; // time_spent заносим время работы первого и второго процессов
            });

            //Этап установки запускается(t2), только в случае успешного завершения процесса сборки(t1).
            // Этап упаковки(t3) запускается, только в случаях успешного завершения процесса сборки и успешного завершения процесса установки.

            // command_1 и command_2 выполняются параллельно (асинхронно)
            // command_3 и command_4 выполняются только после завершения предыдущей задачи, последовательно цепочкой задач(синхронно)
            if (vm.count("install") && res_1 == 0) {
                //then-процесс начнется только после завершения предыдущего
                // mutable можно добавить к переменным класса для указания того,что данная переменная может изменяться даже в константном контексте.
                // в квадратных скобках параметры, с которыми мы будем работать в методах
                auto t2 = t1.then([&res_2, command_3, timeout, &time_spent] () mutable {  //Этап установки
                   //time_t – арифметический тип, представляет собой целочисленное значение – число секунд, прошедших с 00:00, 1 января 1970
                    time_t period_3 = timeout - time_spent; // из времени ожидания вычитаем время выполнения певрого и второго процесса
                    // и получаем оставшееся время для выполнения остальных процессов
                    time_t start_3 = time_now(); // возвращает временную точку, представляющую текущее время старта третьего процесса
                    create_child(command_3, period_3, res_2); // создаем третий процесс, в res_2 будет храниться код выхода из этого процесса
                    time_t end_3 = time_now();// возвращает временную точку, представляющую текущее время завершения третьего процесса

                    time_spent += end_3 - start_3; // time_spent добавляем время работы третьего процесса
                });

                if (vm.count("pack") && res_2 == 0) {
                    //then-процесс начнется только после завершения предыдущего
                    // в квадратных скобках параметры, с которыми мы будем работать в методах
                    auto t3 = t2.then([command_4, timeout, time_spent] () {           //Этап упаковки
                        time_t period_4 = timeout - time_spent;// из времени ожидания вычитаем время выполнения певрого,второго и третьего процесса
                        create_child(command_4, period_4); // содаем четвертый процесс
                    });
                }
            }
        }
        else {
            std::cerr << "config = " << config << " doesn't exist!\n"; //std::cerr вывод  ошибок
        }
    }
}

// если время ожидания истекает, то программа завершает все дочерние запущенные процессы
void create_child(const std::string& command, const time_t& period) {
    std::string line;
    ipstream out; //создание консольного потока out
    child process(command, std_out > out); //child-класс для хранения дочернего процесса, аналогичен std::thread
    //перенаправляем поток из std_out в out,засчет этого происходит запись в консоль команд, которые хранятся в command

    //std::ref(process) объект типа reference_wrapper для хранения ссылки на процесс
    std::thread checkTime(check_time, std::ref(process), std::ref(period));
    // поток обрабатывает метод, который проверяет не истекло ли время и не завершился ли процесс

    //getline - Считывает неформатированные данные из потока out в строку line
    while (out && std::getline(out, line) && !line.empty())
        std::cerr << line << std::endl; //std::cerr вывод ошибок

    checkTime.join(); // ожидание пока поток завершит свою работу
}

void create_child(const std::string& command, const time_t& period, int& res) {
    std::string line;
    ipstream out; //создание консольного потока out
    child process(command, std_out > out);//child-класс для хранения дочернего процесса, аналогичен std::thread
    //перенаправляем поток из std_out в out,засчет этого происходит запись в консоль команд, которые хранятся в command

    //std::ref(process) объект типа reference_wrapper для хранения ссылки на процесс
    std::thread checkTime(check_time, std::ref(process), std::ref(period));
    // поток обрабатывает метод, который проверяет не истекло ли время и не завершился ли процесс

    //getline - Считывает неформатированные данные из потока out в строку line
    while (out && std::getline(out, line) && !line.empty())
        std::cerr << line << std::endl; //std::cerr вывод  ошибок

    checkTime.join();// ожидание пока поток завершит свою работу

    res = process.exit_code(); // заносим в res код выхода
}

void check_time(child& process, const time_t& period) {
    time_t start = time_now(); // возвращает временную точку, представляющую текущее время
    //time_t – арифметический тип, представляет собой целочисленное значение – число секунд, прошедших с 00:00, 1 января 1970
    while (true) { //бесконечный цикл
        if ((time_now() - start > period) && process.running()) { //если текущее время минус время начала больше заданного периода и дочерний процесс запущен
            std::error_code ec; // создается объект который будет содержать код ошибки
            process.terminate(ec); //  завершаем дочерний процесс принудительно, помещая ошибку в ec
            std::cout << ec; //  выводим ошибку
            break;//выход из тела цикла
        }
        else if (!process.running()) { // если процесс не работает, то завершаем цикл
            break;
        }
    }
}
//system_clock – системные часы реального времени
//to_time_t() – преобразует момент времени в тип time_t
//now() – текущий момент времени
//time_t – арифметический тип, представляет собой целочисленное значение – число секунд, прошедших с 00:00, 1 января 1970
time_t time_now() { //возвращает текущий момент времени
    return std::chrono::system_clock::to_time_t(
            std::chrono::system_clock::now()
            );
}

//Boost.Process - это библиотека для управления системными процессами. Может использоваться для:
//
//1. создавать дочерние процессы - child
//2. настроить потоки для дочерних процессов
//3. общаться с дочерними процессами через потоки (синхронно или асинхронно)
//4. ждать завершения процессов (синхронно или асинхронно)
//прекратить процессы

